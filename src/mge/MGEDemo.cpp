#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include "glm.hpp"

#include "mge/core/Renderer.hpp"

#include "mge/core/Mesh.hpp"
#include "mge/core/World.hpp"
#include "mge/core/Texture.hpp"
#include "mge/core/Light.hpp"
#include "mge/core/Camera.hpp"
#include "mge/core/GameObject.hpp"

#include "mge/materials/AbstractMaterial.hpp"
#include "mge/materials/ColorMaterial.hpp"
#include "mge/materials/TextureMaterial.hpp"
#include "mge/materials/LitMaterial.h"
#include "mge/materials/TerrainMaterial.h"

#include "mge/behaviours/RotatingBehaviour.hpp"
#include "mge/behaviours/KeysBehaviour.hpp"
#include "mge/behaviours/LightControlBehaviour.hpp"
#include "mge/behaviours/CameraOrbitBehaviour.h"
#include "mge/behaviours/GridMovementBehavior.hpp"

#include "mge/level/Tile.hpp"
#include "mge/player/Pawn.hpp"
#include "mge/behaviours/PlayfieldFocusBehaviour.h"

#include "mge/util/DebugHud.hpp"

#include "mge/config.hpp"
#include "mge/tileProp.hpp"
#include "mge/MGEDemo.hpp"

#include "mge/util/tinyxml2.h"

//construct the game class into _window, _renderer and hud (other parts are initialized by build)
MGEDemo::MGEDemo() :AbstractGame(), _hud(0) {
}

void MGEDemo::initialize() {
	//setup the core part
	AbstractGame::initialize();

	//setup the custom part so we can display some text
	std::cout << "Initializing HUD" << std::endl;
	_hud = new DebugHud(_window);
	std::cout << "HUD initialized." << std::endl << std::endl;
}

//build the game _world
void MGEDemo::_initializeScene() {
	//Meshes
	Mesh* tileMesh = Mesh::load(config::MGE_MODEL_PATH + "Tile.obj");
	Mesh* cubeMesh = Mesh::load(config::MGE_MODEL_PATH + "cube_flat.obj");

	//Materials
	AbstractMaterial* whiteColorMat = new ColorMaterial(glm::vec3(1, 1, 1));
	AbstractMaterial* blueColorMat = new ColorMaterial(glm::vec3(0, 0, 1)); 
	AbstractMaterial* tileTextureMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + "tileTexture.png"));

	//orthographic settings
	_orthoSize = 12.0f;
	_screenRatio = 4.0f / 3.0f; //default 800x 600

	//setting up main camera
	Camera* camera = new Camera("camera", glm::vec3(0, 0, 0), glm::ortho(-_orthoSize * _screenRatio, _orthoSize * _screenRatio, -_orthoSize, _orthoSize, 0.1f, 1000.0f)); //orthographic camera
	camera->setBehaviour(new PlayfieldFocusBehaviour(-40.0f, -60.0f, 12.0f, 12.0f, camera)); //focus world origin
	_world->add(camera);
	_world->setMainCamera(camera);

	int levelWidth;
	int levelHeight;

	//reference to the read level vector that we treat like a 2d array (filename still hardcoded)
	std::vector<std::string>& levelMap = _readLevelVector(config::MGE_LEVEL_PATH + "TestLevel.xml", levelWidth, levelHeight);

	//build level based on the levelMap array
	for (unsigned i = 0; i < levelMap.size(); i++) {
		std::string tileProperty = levelMap[i];

		//treating the vector as a 2d array
		int col = i % levelWidth;
		int row = i / levelWidth;

		float tileSpace = 2.0f; //should be seamless, since every plane is 2 units wide

		//only create a tile when it should be visible
		if (tileProperty == tileProp::Uncolored || tileProperty == tileProp::PlayerSpawn) {
			Tile* tile = new Tile("tile" + std::to_string(i), glm::vec3(-(col - levelWidth / 2.0f) * tileSpace, 0, (row - levelHeight / 2.0f) * tileSpace));
			tile->setMesh(tileMesh);
			tile->setMaterial(tileTextureMat);
			tile->scale(glm::vec3(1.0f, 1.0f, 1.0f));
			_world->add(tile);
		}

		if (tileProperty == tileProp::PlayerSpawn) {
			Pawn* pawn = new Pawn("pawn", glm::vec3(-(col - levelWidth / 2.0f) * tileSpace, 1, (row - levelHeight / 2.0f) * tileSpace));
			pawn->setMesh(cubeMesh);
			pawn->setMaterial(blueColorMat);
			pawn->setBehaviour(new GridMovementBehavior(tileSpace, true, col, row, levelWidth, levelMap));
			_world->add(pawn);
		}
	}

	_renderer->setClearColor(100, 100, 100, 1); //grey background
}

std::vector<std::string> MGEDemo::_readLevelVector(std::string filepath, int & levelWidth, int & levelHeight) {
	const char * charPath = filepath.c_str(); //converting the input string to a char so tinyxml can read it

	//Reading the xml level file
	tinyxml2::XMLDocument doc;
	tinyxml2::XMLError eResult = doc.LoadFile(charPath);
	if(eResult != tinyxml2::XML_SUCCESS) std::cout << "Failed to load xml file" << std::endl;

	tinyxml2::XMLNode* dummyRoot = doc.FirstChild(); //first root that will always be random information generated by unity

	tinyxml2::XMLNode* playfieldNode = dummyRoot->NextSibling(); //actual first root (PlayfieldContainer)
	if(playfieldNode == nullptr) std::cout << "Null in root" << std::endl;

	tinyxml2::XMLElement* playfieldElement = playfieldNode->FirstChildElement("Playfield"); //get the first child element
	if(playfieldElement == nullptr) std::cout << "Null in element" << std::endl;

	//storing the read width and height as a reference in our ints that are previded from the outside
	playfieldElement->QueryIntAttribute("Height", &levelHeight);
	playfieldElement->QueryIntAttribute("Width", &levelWidth);

	const char* arraymap = playfieldElement->Attribute("Content"); //read list in the element of "Playfield" as char
	std::string arrayString(arraymap); //converting char into a string
	std::istringstream iss(arrayString);

	//vector of chars that represent tile values, split arrayString by " "
	std::vector<std::string> results((std::istream_iterator<std::string>(iss)), std::istream_iterator<std::string>());

	return results;
}

void MGEDemo::_render() {
	AbstractGame::_render();
	_updateHud();
}

void MGEDemo::_updateHud() {
	std::string debugInfo = "";
	debugInfo += std::string("FPS:") + std::to_string((int)_fps) + "\n";

	//Adding the hierarchy and the parent of everything (the world)
	debugInfo += "\n\n" + std::string("Hierarchy:") + "\n" + _world->getName();

	//getting every children in the world object and printing it
	for(int i = 0; i < _world->getChildCount(); i++) {
		debugInfo += "\n\t" + _world->getChildAt(i)->getName();

		for(int j = 0; j < _world->getChildAt(i)->getChildCount(); j++) {
			debugInfo += "\n\t\t" + _world->getChildAt(i)->getChildAt(j)->getName();

			//could potentially get every children of those gameobjects and print their children too, if there were any but 2 iterations is enough for now
			//solution for more and easier iteration would be recursion
		}
	}

	_hud->setDebugInfo(debugInfo);
	_hud->draw();
}

void MGEDemo::_processEvents() {
	sf::Event event;
	bool exit = false;

	//we must empty the event queue
	while(_window->pollEvent(event)) {
		//give all system event listeners a chance to handle events
		//optionally to be implemented by you for example you could implement a
		//SystemEventDispatcher / SystemEventListener pair which allows Listeners to
		//register with the dispatcher and then do something like:
		//SystemEventDispatcher::dispatchEvent(event);

		switch(event.type) {
			case sf::Event::Closed:
				exit = true;
				break;
			case sf::Event::KeyPressed:
				if(event.key.code == sf::Keyboard::Escape) {
					exit = true;
				}

				//Add own key press events here
				break;
			case sf::Event::Resized:
				//would be better to move this to the renderer
				//this version implements nonconstrained match viewport scaling
				
				glViewport(0, 0, event.size.width, event.size.height);

				//readjust the projection matrix when resizing the screen
				_screenRatio = (float)event.size.width / (float)event.size.height;
				_world->getMainCamera()->setProjection(glm::ortho(-_orthoSize * _screenRatio, _orthoSize * _screenRatio, -_orthoSize, _orthoSize, 0.1f, 1000.0f));
				break;

			default:
				break;
		}
	}

	if(exit) {
		_window->close();
	}
}

MGEDemo::~MGEDemo() {
	//dtor
}
