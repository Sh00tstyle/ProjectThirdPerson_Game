#include "mge/managers/ModelManager.h"
#include "mge/util/tinyxml2.h"
#include "mge/materials/AbstractMaterial.hpp"
#include "mge/materials/TextureMaterial.hpp"
#include "mge/core/Mesh.hpp"
#include "mge/core/Texture.hpp"
#include "mge/MGEDemo.hpp"
#include "mge/config.hpp"

//static members
Mesh* ModelManager::_playerMesh;
Mesh* ModelManager::_normalTileMesh;
Mesh* ModelManager::_destinationTileMesh;
Mesh* ModelManager::_pressurePlateMesh;
Mesh* ModelManager::_activatableTileMesh;
Mesh* ModelManager::_colorSwitchMesh;

Mesh* ModelManager::_plane;

AbstractMaterial* ModelManager::_redPlayerMat;
AbstractMaterial* ModelManager::_bluePlayerMat;

std::vector<AbstractMaterial*> ModelManager::_uncoloredTileMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_redTileMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_blueTileMats = std::vector<AbstractMaterial*>();

AbstractMaterial* ModelManager::_redDestinationMat;
AbstractMaterial* ModelManager::_blueDestinationMat;

std::vector<AbstractMaterial*> ModelManager::_redPressurePlateMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_bluePressurePlateMats = std::vector<AbstractMaterial*>();

std::vector<AbstractMaterial*> ModelManager::_redActivatableActiveMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_redActivatableInactiveMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_blueActivatableActiveMats = std::vector<AbstractMaterial*>();
std::vector<AbstractMaterial*> ModelManager::_blueActivatableInactiveMats = std::vector<AbstractMaterial*>();

AbstractMaterial* ModelManager::_redColorSwitchMat;
AbstractMaterial* ModelManager::_blueColorSwitchMat;

ModelManager::ModelManager(std::string filename) {
	_loadMeshesAndMats(filename);
}

ModelManager::~ModelManager() {
	_unloadModels();
}

Mesh * ModelManager::GetNormalTileMesh() {
	return _normalTileMesh;
}

Mesh * ModelManager::GetDestinationTileMesh() {
	return _destinationTileMesh;
}

Mesh * ModelManager::GetPressurePlateMesh() {
	return _pressurePlateMesh;
}

Mesh * ModelManager::GetActivatableTileMesh() {
	return _activatableTileMesh;
}

Mesh * ModelManager::GetColorSwitchMesh() {
	return _colorSwitchMesh;
}

Mesh* ModelManager::GetPlayerMesh() {
	return _playerMesh;
}

Mesh * ModelManager::GetPlane() {
	return _plane;
}

AbstractMaterial * ModelManager::GetRedPlayerMat() {
	return _redPlayerMat;
}

AbstractMaterial * ModelManager::GetBluePlayerMat() {
	return _bluePlayerMat;
}

AbstractMaterial * ModelManager::GetRndUncoloredMat() {
	return _uncoloredTileMats[rand() % _uncoloredTileMats.size()];
}

AbstractMaterial * ModelManager::GetRndRedTileMat() {
	return _redTileMats[rand() % _redTileMats.size()];
}

AbstractMaterial * ModelManager::GetRndBlueTileMat() {
	return _blueTileMats[rand() % _blueTileMats.size()];
}

AbstractMaterial * ModelManager::GetRedDestinationMat() {
	return _redDestinationMat;
}

AbstractMaterial * ModelManager::GetBlueDestinationMat() {
	return _blueDestinationMat;
}

AbstractMaterial * ModelManager::GetRedPressurePlateMat(int id) {
	return _redPressurePlateMats[id];
}

AbstractMaterial * ModelManager::GetBluePressurePlateMat(int id) {
	return _bluePressurePlateMats[id];
}

AbstractMaterial * ModelManager::GetRedActivatableTileActiveMat(int id) {
	return _redActivatableActiveMats[id];
}

AbstractMaterial * ModelManager::GetRedActivatableTileInactiveMat(int id) {
	return _redActivatableInactiveMats[id];
}

AbstractMaterial * ModelManager::GetBlueActivatableTileActiveMat(int id) {
	return _blueActivatableActiveMats[id];
}

AbstractMaterial * ModelManager::GetBlueActivatableTileInactiveMat(int id) {
	return _blueActivatableInactiveMats[id];
}

AbstractMaterial * ModelManager::GetRedColorSwitchMat() {
	return _redColorSwitchMat;
}

AbstractMaterial * ModelManager::GetBlueColorSwitchMat() {
	return _blueColorSwitchMat;
}

void ModelManager::_loadMeshesAndMats(std::string filename) {
	//parse and load meshes and textures/materials here

	const char * charPath = filename.c_str(); //converting the input string to a char so tinyxml can read it

    //Reading the xml level file
	tinyxml2::XMLDocument doc;
	tinyxml2::XMLError eResult = doc.LoadFile(charPath);
	if(eResult != tinyxml2::XML_SUCCESS) std::cout << "Failed to load xml file" << std::endl;
	MGEDemo::UpdateLoadingScreen(33);

	tinyxml2::XMLNode* root = doc.FirstChild(); //first root that will always be random information generated by unity
	root = root->NextSibling(); //actual first root (ModelContainer)

	//normal tile model
	tinyxml2::XMLElement* element = root->FirstChildElement("NormalTileModel");
	if(element == nullptr) std::cout << "Null in NormalTileModel" << std::endl;

	const char* readChar = element->Attribute("ModelFile");
	std::string tileModelFileString(readChar);

	_normalTileMesh = Mesh::load(config::MGE_MODEL_PATH + tileModelFileString);
	MGEDemo::UpdateLoadingScreen(36);

	//destination tile model
	element = root->FirstChildElement("DestinationTileModel");
	if(element == nullptr) std::cout << "Null in DestinationTileModel" << std::endl;

	readChar = element->Attribute("ModelFile");
	std::string destinationModelFileString(readChar);

	_destinationTileMesh = Mesh::load(config::MGE_MODEL_PATH + destinationModelFileString);
	MGEDemo::UpdateLoadingScreen(38);

	//pressure plate model
	element = root->FirstChildElement("PressurePlateModel");
	if(element == nullptr) std::cout << "Null in PressurePlateModel" << std::endl;

	readChar = element->Attribute("ModelFile");
	std::string pressureModelFileString(readChar);

	_pressurePlateMesh = Mesh::load(config::MGE_MODEL_PATH + pressureModelFileString);
	MGEDemo::UpdateLoadingScreen(40);

	//activatable tile model
	element = root->FirstChildElement("ActivatableTileModel");
	if(element == nullptr) std::cout << "Null in ActivatableTileModel" << std::endl;

	readChar = element->Attribute("ModelFile");
	std::string activatableModelFileString(readChar);

	_activatableTileMesh = Mesh::load(config::MGE_MODEL_PATH + activatableModelFileString);
	MGEDemo::UpdateLoadingScreen(43);

	//color swtich model
	element = root->FirstChildElement("ColorSwitchModel");
	if(element == nullptr) std::cout << "Null in ColorSwitchModel" << std::endl;

	readChar = element->Attribute("ModelFile");
	std::string colorswitchModelFileString(readChar);

	_colorSwitchMesh = Mesh::load(config::MGE_MODEL_PATH + colorswitchModelFileString);
	MGEDemo::UpdateLoadingScreen(45);

	//player model
	element = root->FirstChildElement("PlayerModel");
	if(element == nullptr) std::cout << "Null in PlayerModel" << std::endl;

	readChar = element->Attribute("ModelFile");
	std::string playerModelFileString(readChar);

	_playerMesh = Mesh::load(config::MGE_MODEL_PATH + playerModelFileString);
	MGEDemo::UpdateLoadingScreen(48);

	//red player texture
	element = root->FirstChildElement("RedPlayerTexture");
	if(element == nullptr) std::cout << "Null in RedPlayerTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string redPlayerTex(readChar);

	_redPlayerMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redPlayerTex));
	MGEDemo::UpdateLoadingScreen(54);

	//blue player texture
	element = root->FirstChildElement("BluePlayerTexture");
	if(element == nullptr) std::cout << "Null in BluePlayerTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string bluePlayerTex(readChar);

	_bluePlayerMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + bluePlayerTex));

	//uncolored tile textures
	element = root->FirstChildElement("UncoloredTileTextures");
	if(element == nullptr) std::cout << "Null in UncoloredTileTextures" << std::endl;

	tinyxml2::XMLElement* listElement = element->FirstChildElement("UncoloredTileTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string uncoloredTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + uncoloredTexture));
		_uncoloredTileMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("UncoloredTileTexture");
	}

	//red tile textures
	element = root->FirstChildElement("RedTileTextures");
	if(element == nullptr) std::cout << "Null in RedTileTextures" << std::endl;

	listElement = element->FirstChildElement("RedTileTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string redTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redTexture));
		_redTileMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("RedTileTexture");
	}

	//blue tile textures
	element = root->FirstChildElement("BlueTileTextures");
	if(element == nullptr) std::cout << "Null in BlueTileTextures" << std::endl;

	listElement = element->FirstChildElement("BlueTileTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string blueTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueTexture));
		_blueTileMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("BlueTileTexture");
	}

	//red destination texture
	element = root->FirstChildElement("RedDestinationTileTexture");
	if(element == nullptr) std::cout << "Null in RedDestinationTileTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string redDestinationTileTex(readChar);

	_redDestinationMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redDestinationTileTex));

	//blue destination texture
	element = root->FirstChildElement("BlueDestinationTileTexture");
	if(element == nullptr) std::cout << "Null in BlueDestinationTileTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string blueDestinationTileTex(readChar);

	_blueDestinationMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueDestinationTileTex));

	//red pressure plate textures
	element = root->FirstChildElement("RedPressurePlateTextures");
	if(element == nullptr) std::cout << "Null in RedPressurePlateTextures" << std::endl;

	listElement = element->FirstChildElement("RedPressurePlateTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string redTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redTexture));
		_redPressurePlateMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("RedPressurePlateTexture");
	}

	//blue pressure plate textures
	element = root->FirstChildElement("BluePressurePlateTextures");
	if(element == nullptr) std::cout << "Null in BluePressurePlateTextures" << std::endl;

	listElement = element->FirstChildElement("BluePressurePlateTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string blueTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueTexture));
		_bluePressurePlateMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("BluePressurePlateTexture");
	}

	//red activatable tile textures (active)
	element = root->FirstChildElement("RedActivatableTileActiveTextures");
	if(element == nullptr) std::cout << "Null in RedActivatableTileActiveTextures" << std::endl;

	listElement = element->FirstChildElement("RedActivatableTileActiveTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string redTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redTexture));
		_redActivatableActiveMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("RedActivatableTileActiveTexture");
	}

	//red activatable tile textures (inactive)
	element = root->FirstChildElement("RedActivatableTileInactiveTextures");
	if(element == nullptr) std::cout << "Null in RedActivatableTileInactiveTextures" << std::endl;

	listElement = element->FirstChildElement("RedActivatableTileInactiveTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string redTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redTexture));
		_redActivatableInactiveMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("RedActivatableTileInactiveTexture");
	}

	//blue activatable tile textures (active)
	element = root->FirstChildElement("BlueActivatableTileActiveTextures");
	if(element == nullptr) std::cout << "Null in BlueActivatableTileActiveTextures" << std::endl;

	listElement = element->FirstChildElement("BlueActivatableTileActiveTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string blueTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueTexture));
		_blueActivatableActiveMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("BlueActivatableTileActiveTexture");
	}

	//blue activatable tile textures (inactive)
	element = root->FirstChildElement("BlueActivatableTileInactiveTextures");
	if(element == nullptr) std::cout << "Null in BlueActivatableTileInactiveTextures" << std::endl;

	listElement = element->FirstChildElement("BlueActivatableTileInactiveTexture");

	while(listElement != nullptr) {
		readChar = listElement->Attribute("TextureFile");
		std::string blueTexture(readChar);

		AbstractMaterial* newMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueTexture));
		_blueActivatableInactiveMats.push_back(newMat);

		listElement = listElement->NextSiblingElement("BlueActivatableTileInactiveTexture");
	}

	//red color switch texture
	element = root->FirstChildElement("RedColorSwitchTexture");
	if(element == nullptr) std::cout << "Null in RedColorSwitchTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string redColorSwitchTex(readChar);

	_redColorSwitchMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + redColorSwitchTex));

	//blue color switch texture
	element = root->FirstChildElement("BlueColorSwitchTexture");
	if(element == nullptr) std::cout << "Null in BlueColorSwitchTexture" << std::endl;

	readChar = element->Attribute("TextureFile");
	std::string blueColorSwitchTex(readChar);

	_blueColorSwitchMat = new TextureMaterial(Texture::load(config::MGE_TEXTURE_PATH + blueColorSwitchTex));

	//load plane
	_plane = Mesh::load(config::MGE_MODEL_PATH + "plane.obj");

	MGEDemo::UpdateLoadingScreen(60);
}

void ModelManager::_unloadModels() {
	//remove player and tile mesh
	delete _normalTileMesh;
	delete _destinationTileMesh;
	delete _pressurePlateMesh;
	delete _activatableTileMesh;
	delete _colorSwitchMesh;

	delete _playerMesh;

	//remove player mats
	delete _redPlayerMat;
	delete _bluePlayerMat;

	//remove uncolored tile mats
	for(unsigned i = 0; i < _uncoloredTileMats.size(); i++) {
		if(_uncoloredTileMats[i] == nullptr) continue;

		delete _uncoloredTileMats[i];
	}

	//remove red tile mats
	for(unsigned i = 0; i < _redTileMats.size(); i++) {
		if(_redTileMats[i] == nullptr) continue;

		delete _redTileMats[i];
	}

	//remove blue tile mats
	for(unsigned i = 0; i < _blueTileMats.size(); i++) {
		if(_blueTileMats[i] == nullptr) continue;

		delete _blueTileMats[i];
	}

	//remove destination tile mats
	delete _redDestinationMat;
	delete _blueDestinationMat;

	//remove red pressure plate mats
	for(unsigned i = 0; i < _redPressurePlateMats.size(); i++) {
		if(_redPressurePlateMats[i] == nullptr) continue;

		delete _redPressurePlateMats[i];
	}

	//remove blue pressure plate mats
	for(unsigned i = 0; i < _bluePressurePlateMats.size(); i++) {
		if(_bluePressurePlateMats[i] == nullptr) continue;

		delete _bluePressurePlateMats[i];
	}

	//remove red activatable tile mats (active)
	for(unsigned i = 0; i < _redActivatableActiveMats.size(); i++) {
		if(_redActivatableActiveMats[i] == nullptr) continue;

		delete _redActivatableActiveMats[i];
	}

	//remove red activatable tile mats (inactive)
	for(unsigned i = 0; i < _redActivatableInactiveMats.size(); i++) {
		if(_redActivatableInactiveMats[i] == nullptr) continue;

		delete _redActivatableInactiveMats[i];
	}

	//remove blue activatable tile mats (active)
	for(unsigned i = 0; i < _blueActivatableActiveMats.size(); i++) {
		if(_blueActivatableActiveMats[i] == nullptr) continue;

		delete _blueActivatableActiveMats[i];
	}

	//remove blue activatable tile mats (inactive)
	for(unsigned i = 0; i < _blueActivatableInactiveMats.size(); i++) {
		if(_blueActivatableInactiveMats[i] == nullptr) continue;

		delete _blueActivatableInactiveMats[i];
	}

	//remove color switch mats
	delete _redColorSwitchMat;
	delete _blueColorSwitchMat;
}
